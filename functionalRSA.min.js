const 
  b = require("big-integer"),
  r = require("random-number-csprng"),
  p = require("quick-is-prime"),
  CODE_BASE = b(127),
  E = b(65537),
  randPrime = async existing => {
  const num = await r(0, 40000000);
    return p(num) && (!existing || num !== existing.valueOf())
      ? b(num)
      : randPrime(existing);
  },
  charArrayTob = (sum, letter, idx, arr) =>
    sum.add(
      b(letter.charCodeAt()).multiply(CODE_BASE.pow(arr.length - idx))
  ),
  encodeMessage = str => str.split("").reduce(charArrayToBigInt, b(0)),
  remainderToChar = (r, pow) =>
    String.fromCharCode(r.divide(CODE_BASE.pow(pow - 1)).valueOf()),
  getChars = (num, pow = 2) => {
    const { quotient: q, remainder: r } = num.divmod(CODE_BASE.pow(pow));
    return q.eq(0)
      ? [remainderToChar(r, pow)]
      : [...getChars(num.minus(r), pow + 1), remainderToChar(r, pow)];
  },
  decodeMessage = num => getChars(num).join(""),
  generateKeys = async () => {
    const 
      p = await randPrime(),
      q = await randPrime(p),
      n = p.multiply(q),
      λ = b.lcm(p.minus(1), q.minus(1));
    return λ.greater(E) ? { n, λ } : generateKeys();
  },
  RSA = async msg => {
    const 
      { n, λ } = await generateKeys(),
      d = E.modInv(λ),
      cmsg = encodeMessage(msg);

    if (cmsg.greater(n)) { console.log("msg too long"); return; }

    const 
      c = cmsg.modPow(E, n),
      m = c.modPow(d, n),
      original = decodeMessage(m);
    console.log(`Generated cyphertext: ${c.valueOf()}`);
    console.log(`Original message: ${original}`);
  };
RSA("age");